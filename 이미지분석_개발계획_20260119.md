# 이미지 분석 기능 개발 계획

**작성일**: 2026-01-19
**상태**: 구현 완료
**목적**: SmilePrint Image-to-Text API를 활용한 문제 사진 분석 기능 개발

---

## 구현 완료 내역

### 생성된 파일
- `app/src/services/ImageAnalysisService.js` - SmilePrint API 서비스

### 수정된 파일
- `app/src/game/Game.js`
  - ImageAnalysisService import 추가
  - completeRegister() 메서드 수정 (SmilePrint 우선, Gemini 폴백)
  - 설정 화면에 SmilePrint API 키 입력 추가
  - promptSmilePrintApiKey() 메서드 추가

### 선택된 Prompt 방안
- **A 방안 (구조화된 분석)** 선택

### 버그 수정 (2026-01-19)
- `|| '정답'` 기본값 제거 → 빈 문자열로 변경
- 정답이 없을 경우 선택지에서 correctIndex로 정답 추출
- 그래도 없으면 '?' 표시

### Prompt 개선 (2026-01-19)
- AI가 정답과 비슷한 오답 3개를 자동 생성하도록 prompt 수정
- 오답 생성 규칙 추가 (숫자, 단어, 수식 각각 다른 방식)
- choices[0]에 정답, 나머지에 오답 배치
- 선택지 반드시 4개 생성

### 복수 정답 지원 (2026-01-19)
- 이차방정식 등 복수 정답 지원 (answers 배열)
- 새 필드 추가: questionType, formula, answers
- 오답 생성 규칙 개선 (복수 정답에 대한 오답 생성)
- 상세 풀이 과정 포함

---

## 1. API 정보

| 항목 | 값 |
|------|-----|
| 엔드포인트 | `POST /api/v1/analyze/image` |
| 베이스 URL | `https://caricature-api-rust.wizice.com` |
| 모델 | `gemini-3-flash-preview` (최고 품질) |
| 인증 | `X-API-Key` 헤더 |
| 처리 방식 | 비동기 (Job 생성 → 상태 폴링) |

---

## 2. Prompt 방안

### 방안 A: 구조화된 분석 (권장)

```
당신은 한국 고등학교 {과목} 시험 문제 분석 전문가입니다.

## 작업
이 이미지에서 시험 문제를 분석하여 정보를 추출하세요.

## 분석 단계
1. 이미지에서 문제 텍스트를 정확히 읽어주세요
2. 선택지(보기)가 있다면 모두 추출하세요
3. 정답이 표시되어 있다면 확인하세요
4. 정답이 없다면 문제를 풀어서 정답을 도출하세요
5. 문제의 주제/단원을 파악하세요

## 출력 형식
반드시 아래 JSON 형식으로만 응답하세요. 다른 텍스트는 포함하지 마세요.

{
  "success": true,
  "question": "문제 전체 내용",
  "answer": "정답",
  "choices": ["①", "②", "③", "④"],
  "correctIndex": 0,
  "explanation": "풀이 과정 설명",
  "topic": "단원/주제",
  "difficulty": "상/중/하",
  "keywords": ["키워드1", "키워드2"]
}

## 주의사항
- question: 문제 전문을 그대로 추출 (수식, 기호 포함)
- choices: 선택지 배열 (없으면 빈 배열 [])
- correctIndex: choices에서 정답 위치 (0부터 시작)
- 이미지가 불명확하면 success: false와 함께 오류 메시지 반환
```

### 방안 B: 간단 분석

```
이 시험 문제 이미지를 분석해주세요.

다음 JSON 형식으로만 응답:
{
  "question": "문제 내용",
  "answer": "정답",
  "choices": ["보기1", "보기2", "보기3", "보기4"],
  "correctIndex": 0,
  "explanation": "풀이"
}
```

### 방안 C: 과목별 특화 분석

```
당신은 한국 고등학교 {과목} 전문 교사입니다.

[수학인 경우]
- 수식을 LaTeX 형식으로 표현하세요
- 계산 과정을 단계별로 설명하세요

[영어인 경우]
- 지문이 있다면 함께 추출하세요
- 문법/어휘/독해 유형을 구분하세요

[국어인 경우]
- 지문/작품명을 추출하세요
- 문학/비문학 유형을 구분하세요

[과학인 경우]
- 그림/도표 설명을 포함하세요
- 관련 공식/개념을 명시하세요

출력 형식: JSON
{
  "question": "문제",
  "answer": "정답",
  "choices": [],
  "correctIndex": 0,
  "explanation": "풀이",
  "topic": "단원",
  "type": "문제유형"
}
```

---

## 3. 오답 데이터 관리 방안

### 3.1 데이터 구조

```javascript
// IndexedDB 'monsters' 스토어 스키마 확장
const wrongAnswerSchema = {
  // 기본 정보
  id: "auto-generated",
  subject: "math",           // 과목 ID
  createdAt: Date.now(),
  status: "alive",           // alive, defeated, archived

  // 문제 정보 (AI 분석 결과)
  question: "문제 내용",
  answer: "정답",
  choices: ["①", "②", "③", "④"],
  correctIndex: 0,
  explanation: "풀이 설명",

  // 분류 정보
  topic: "단원/주제",
  difficulty: 2,             // 1: 쉬움, 2: 보통, 3: 어려움
  keywords: ["키워드1", "키워드2"],
  type: "객관식",            // 객관식, 주관식, 서술형

  // 이미지 정보
  imageData: "base64...",    // 원본 이미지
  imageUrl: null,            // 외부 저장 URL (선택)

  // 게임 정보
  hp: 100,
  maxHp: 100,

  // AI 분석 메타데이터
  aiAnalysis: {
    model: "gemini-3-flash-preview",
    confidence: 0.95,        // 분석 신뢰도
    processingTime: 2500,    // 처리 시간 (ms)
    cost: 0.01,              // 비용 ($)
    analyzedAt: Date.now()
  },

  // 학습 통계
  stats: {
    attempts: 0,             // 풀이 시도 횟수
    correct: 0,              // 정답 횟수
    wrong: 0,                // 오답 횟수
    lastAttempt: null,       // 마지막 시도 시간
    averageTime: 0           // 평균 풀이 시간 (초)
  },

  // 복습 관리
  review: {
    nextReviewDate: null,    // 다음 복습 예정일
    reviewCount: 0,          // 복습 횟수
    masteryLevel: 0          // 숙달도 (0-100)
  },

  // 관련 문제
  relatedProblems: [],       // AI 생성 유사 문제 ID 목록
  parentId: null,            // 원본 문제 ID (유사 문제인 경우)
  isGenerated: false         // AI 생성 여부
};
```

### 3.2 데이터 저장 흐름

```
[사진 촬영]
    ↓
[과목 선택]
    ↓
[SmilePrint API 호출]
    ↓
[AI 분석 결과 수신]
    ↓
[사용자 검토/수정]
    ↓
[IndexedDB 저장]
    ↓
[몬스터로 등록]
```

### 3.3 데이터 관리 기능

#### A. 오답 목록 조회
```javascript
// 과목별 조회
db.getByIndex('monsters', 'subject', 'math')

// 상태별 조회
db.getByIndex('monsters', 'status', 'alive')

// 난이도별 조회
db.getByIndex('monsters', 'difficulty', 3)
```

#### B. 학습 통계 업데이트
```javascript
// 문제 풀이 후 통계 갱신
function updateStats(monsterId, isCorrect, timeSpent) {
  const monster = await db.get('monsters', monsterId);
  monster.stats.attempts++;
  if (isCorrect) {
    monster.stats.correct++;
  } else {
    monster.stats.wrong++;
  }
  monster.stats.lastAttempt = Date.now();
  monster.stats.averageTime = calculateAverage(...);
  await db.put('monsters', monster);
}
```

#### C. 복습 스케줄링 (간격 반복)
```javascript
// 에빙하우스 망각 곡선 기반 복습 일정
function calculateNextReview(masteryLevel, reviewCount) {
  const intervals = [1, 3, 7, 14, 30, 60]; // 일 단위
  const idx = Math.min(reviewCount, intervals.length - 1);
  const days = intervals[idx];
  return Date.now() + (days * 24 * 60 * 60 * 1000);
}
```

#### D. 데이터 내보내기/가져오기
```javascript
// JSON 내보내기
async function exportData() {
  const monsters = await db.getAll('monsters');
  const blob = new Blob([JSON.stringify(monsters)], {type: 'application/json'});
  // 다운로드 처리
}

// JSON 가져오기
async function importData(jsonFile) {
  const data = JSON.parse(await jsonFile.text());
  for (const monster of data) {
    await db.add('monsters', monster);
  }
}
```

### 3.4 인덱스 설계

```javascript
// IndexedDB 인덱스
const indexes = [
  { name: 'subject', keyPath: 'subject' },
  { name: 'status', keyPath: 'status' },
  { name: 'difficulty', keyPath: 'difficulty' },
  { name: 'topic', keyPath: 'topic' },
  { name: 'createdAt', keyPath: 'createdAt' },
  { name: 'nextReviewDate', keyPath: 'review.nextReviewDate' },
  { name: 'masteryLevel', keyPath: 'review.masteryLevel' }
];
```

---

## 4. 구현 계획

### 4.1 새로운 서비스 생성

```
app/src/services/
├── GeminiService.js      (기존 - Gemini API 직접 호출)
└── ImageAnalysisService.js (신규 - SmilePrint API)
```

### 4.2 ImageAnalysisService 기능

| 메서드 | 설명 |
|--------|------|
| `analyzeImage(imageData, subject)` | 이미지 분석 요청 |
| `checkStatus(jobId, accessKey)` | 분석 상태 확인 |
| `waitForCompletion(jobId, accessKey)` | 완료까지 대기 (폴링) |

### 4.3 API 키 관리

- SmilePrint API 키를 별도로 관리
- 설정 화면에서 입력 가능
- localStorage에 저장

---

## 5. 검토 요청 사항

1. **Prompt 방안 선택**: A, B, C 중 어떤 것을 사용할까요?
2. **데이터 구조**: 추가/수정할 필드가 있나요?
3. **복습 기능**: 간격 반복 복습 기능이 필요한가요?
4. **API 키**: SmilePrint API 키가 있나요?

---

## 6. 참고: 지원 모델 목록

| 모델 ID | 비용 | 특징 |
|---------|------|------|
| `gemini-1.5-flash` | $0.01 | 빠르고 저렴 |
| `gemini-1.5-pro` | $0.02 | 높은 정확도 |
| `gemini-2.0-flash-exp` | $0.01 | 최신 모델 |
| `gemini-3-flash-preview` | TBD | 최고 품질 (요청) |
| `gpt-4o` | $0.015 | OpenAI 비전 |
| `claude-sonnet-4` | $0.015 | 상세한 분석 |
