# 오답헌터 데이터 Cloudflare D1 저장 방안

## 현재 상태 (브라우저 로컬 저장)

| 저장 위치 | 키 | 데이터 |
|-----------|-----|--------|
| IndexedDB | player | 플레이어 정보 (레벨, 스탯) |
| IndexedDB | monsters | 오답 몬스터 데이터 |
| IndexedDB | items | 아이템 정보 |
| IndexedDB | runs | 플레이 기록 |
| localStorage | gemini_api_key | Gemini API 키 |
| localStorage | smileprint_api_key | 이미지분석 API 키 |
| localStorage | sfx_enabled, bgm_enabled | 사운드 설정 |
| localStorage | sound_volume, bgm_volume | 볼륨 설정 |

### 문제점
- 브라우저 캐시 삭제 시 전부 소실
- 기기 변경 시 데이터 이동 불가
- API 키가 브라우저에 평문으로 저장 (보안 취약)

---

## 목표 구조

```
[사용자 브라우저/휴대폰]
       ↓ Google 로그인 버튼 클릭
[Google OAuth 2.0]  → ID Token 발급
       ↓
[Cloudflare Workers API]  ← ID Token 검증 + 암호화/복호화
       ↕
[Cloudflare D1 Database]  ← SQLite 기반 서버리스 DB
```

---

## D1 무료 범위

| 항목 | 무료 한도 |
|------|----------|
| 저장 용량 | DB당 500MB |
| DB 개수 | 10개 |
| 읽기 | 일 500만 rows |
| 쓰기 | 일 10만 rows |
| 비용 | 무료 |

오답헌터 규모에서는 무료 한도를 초과할 일이 없음.

---

## Google OAuth 2.0 로그인 설계

### 사전 준비: Google Cloud Console에서 OAuth 클라이언트 생성

1. https://console.cloud.google.com 접속
2. 새 프로젝트 생성 (예: odap-hunter)
3. **API 및 서비스 → OAuth 동의 화면** 설정
   - User Type: **외부** 선택
   - 앱 이름, 이메일 입력
   - 범위(scope): `email`, `profile` 추가
4. **API 및 서비스 → 사용자 인증 정보 → OAuth 2.0 클라이언트 ID 만들기**
   - 애플리케이션 유형: **웹 애플리케이션**
   - 승인된 JavaScript 출처: `https://study-bhi.pages.dev`
   - 승인된 리디렉션 URI: `https://study-bhi.pages.dev`
5. **클라이언트 ID**와 **클라이언트 시크릿** 메모

### 로그인 흐름

```
1. 사용자가 "Google로 로그인" 버튼 클릭
        ↓
2. Google 로그인 팝업 표시 (Google Identity Services)
        ↓
3. 사용자가 Google 계정 선택/로그인
        ↓
4. Google이 ID Token(JWT) 발급 → 브라우저로 전달
        ↓
5. 브라우저가 ID Token을 Workers API에 전송
   POST /api/auth/google  { token: "eyJhbG..." }
        ↓
6. Workers에서 ID Token 검증
   - Google 공개키로 JWT 서명 검증
   - iss(발급자), aud(클라이언트ID), exp(만료) 확인
        ↓
7. D1에서 사용자 조회 → 없으면 자동 회원가입
        ↓
8. 세션 토큰(JWT) 발급 → 브라우저로 반환
        ↓
9. 이후 모든 API 요청에 세션 토큰 포함
   Authorization: Bearer <세션토큰>
```

### 프론트엔드 Google 로그인 코드

```html
<!-- index.html에 추가 -->
<script src="https://accounts.google.com/gsi/client" async defer></script>
```

```javascript
// Google Identity Services 초기화
google.accounts.id.initialize({
  client_id: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com',
  callback: handleGoogleLogin
});

// 로그인 버튼 렌더링
google.accounts.id.renderButton(
  document.getElementById('google-login-btn'),
  { theme: 'outline', size: 'large', text: 'signin_with', locale: 'ko' }
);

// Google 로그인 콜백
async function handleGoogleLogin(response) {
  // Google ID Token을 Workers API로 전송
  const res = await fetch('https://study-api.YOUR_SUBDOMAIN.workers.dev/api/auth/google', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ token: response.credential })
  });

  const data = await res.json();
  if (data.success) {
    // 세션 토큰 저장
    localStorage.setItem('session_token', data.sessionToken);
    localStorage.setItem('user_name', data.user.name);
    localStorage.setItem('user_picture', data.user.picture);
    // 게임 시작
    startGame();
  }
}
```

### Workers에서 Google ID Token 검증

```javascript
// src/routes/auth.js

async function googleLogin(request, env) {
  const { token } = await request.json();

  // 1. Google 공개키 가져오기 (캐시됨)
  const googleCerts = await fetch('https://www.googleapis.com/oauth2/v3/certs')
    .then(r => r.json());

  // 2. ID Token 디코딩 및 검증
  const payload = await verifyGoogleToken(token, googleCerts, env.GOOGLE_CLIENT_ID);
  if (!payload) {
    return new Response(JSON.stringify({ error: '인증 실패' }), { status: 401 });
  }

  // 3. payload에서 사용자 정보 추출
  const { sub: googleId, email, name, picture } = payload;

  // 4. D1에서 사용자 조회 → 없으면 자동 생성
  let user = await env.DB.prepare(
    'SELECT * FROM users WHERE google_id = ?'
  ).bind(googleId).first();

  if (!user) {
    // 첫 로그인 → 자동 회원가입
    const userId = crypto.randomUUID();
    await env.DB.batch([
      env.DB.prepare(
        'INSERT INTO users (id, google_id, email, name, picture) VALUES (?, ?, ?, ?, ?)'
      ).bind(userId, googleId, email, name, picture),
      env.DB.prepare(
        'INSERT INTO players (user_id) VALUES (?)'
      ).bind(userId),
      env.DB.prepare(
        'INSERT INTO user_settings (user_id) VALUES (?)'
      ).bind(userId)
    ]);
    user = { id: userId, google_id: googleId, email, name, picture };
  } else {
    // 기존 사용자 → 마지막 로그인 시간 업데이트
    await env.DB.prepare(
      "UPDATE users SET last_login = datetime('now'), name = ?, picture = ? WHERE id = ?"
    ).bind(name, picture, user.id).run();
  }

  // 5. 세션 토큰(JWT) 발급
  const sessionToken = await createJWT({ userId: user.id, email }, env.JWT_SECRET);

  return new Response(JSON.stringify({
    success: true,
    sessionToken,
    user: { id: user.id, name, email, picture }
  }));
}
```

---

## D1 데이터베이스 스키마 설계

### 1. users (사용자 - Google 로그인 기반)

```sql
CREATE TABLE users (
  id TEXT PRIMARY KEY,              -- 내부 사용자 ID (UUID)
  google_id TEXT NOT NULL UNIQUE,   -- Google 고유 ID (sub 클레임)
  email TEXT NOT NULL,              -- Google 이메일
  name TEXT,                        -- Google 표시 이름
  picture TEXT,                     -- Google 프로필 사진 URL
  created_at TEXT DEFAULT (datetime('now')),
  last_login TEXT DEFAULT (datetime('now'))
);

CREATE INDEX idx_users_google ON users(google_id);
CREATE INDEX idx_users_email ON users(email);
```

### 2. players (플레이어 게임 데이터)

```sql
CREATE TABLE players (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL UNIQUE,   -- users.id 참조
  level INTEGER DEFAULT 1,
  exp INTEGER DEFAULT 0,
  hp INTEGER DEFAULT 100,
  attack INTEGER DEFAULT 10,
  defense INTEGER DEFAULT 5,
  gold INTEGER DEFAULT 0,
  data TEXT,                      -- 기타 스탯 JSON
  updated_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 3. monsters (오답 몬스터)

```sql
CREATE TABLE monsters (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  subject TEXT,                   -- 과목
  question TEXT,                  -- 문제 내용
  answer TEXT,                    -- 정답
  wrong_answer TEXT,              -- 오답
  explanation TEXT,               -- 해설
  status TEXT DEFAULT 'alive',    -- alive / defeated / mastered
  difficulty INTEGER DEFAULT 1,
  created_at TEXT DEFAULT (datetime('now')),
  defeated_at TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_monsters_user ON monsters(user_id);
CREATE INDEX idx_monsters_subject ON monsters(user_id, subject);
CREATE INDEX idx_monsters_status ON monsters(user_id, status);
```

### 4. items (아이템)

```sql
CREATE TABLE items (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  item_type TEXT NOT NULL,        -- 아이템 종류
  item_name TEXT NOT NULL,
  quantity INTEGER DEFAULT 1,
  data TEXT,                      -- 추가 속성 JSON
  acquired_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_items_user ON items(user_id);
```

### 5. runs (플레이 기록)

```sql
CREATE TABLE runs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  start_time TEXT NOT NULL,
  end_time TEXT,
  score INTEGER DEFAULT 0,
  monsters_defeated INTEGER DEFAULT 0,
  data TEXT,                      -- 상세 기록 JSON
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_runs_user ON runs(user_id);
CREATE INDEX idx_runs_date ON runs(user_id, start_time);
```

### 6. user_settings (사용자 설정)

```sql
CREATE TABLE user_settings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL UNIQUE,
  sfx_enabled INTEGER DEFAULT 1,   -- 1=ON, 0=OFF
  bgm_enabled INTEGER DEFAULT 1,
  sound_volume REAL DEFAULT 0.5,
  bgm_volume REAL DEFAULT 0.35,
  updated_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 7. encrypted_keys (API 키 암호화 저장)

```sql
CREATE TABLE encrypted_keys (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  key_name TEXT NOT NULL,          -- 'gemini_api_key', 'smileprint_api_key'
  encrypted_value TEXT NOT NULL,   -- AES-GCM 암호화된 값
  iv TEXT NOT NULL,                -- 초기화 벡터 (Base64)
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  UNIQUE(user_id, key_name),
  FOREIGN KEY (user_id) REFERENCES users(id)
);
```

---

## API 키 암호화 방식

### 암호화 알고리즘: AES-256-GCM
- 인증된 암호화 (데이터 무결성 + 기밀성)
- Cloudflare Workers에서 Web Crypto API로 네이티브 지원
- 마스터 키는 Workers Secret으로 안전하게 보관

### 암호화 흐름

```
[사용자가 API 키 입력]
        ↓
[Workers API 호출 (HTTPS)]
        ↓
[Workers에서 암호화]
  1. 랜덤 IV(12바이트) 생성
  2. MASTER_KEY(Workers Secret)로 AES-GCM 키 파생
  3. API 키를 AES-256-GCM으로 암호화
  4. 암호문 + IV를 D1에 저장
        ↓
[D1에 encrypted_value + iv 저장]
```

### 복호화 흐름

```
[사용자가 API 키 필요한 작업 요청]
        ↓
[Workers에서 D1 조회]
        ↓
[Workers에서 복호화]
  1. D1에서 encrypted_value + iv 조회
  2. MASTER_KEY로 AES-GCM 복호화
  3. 복호화된 API 키로 외부 API 호출
        ↓
[결과를 사용자에게 반환]
```

> 복호화된 API 키는 절대 클라이언트(브라우저)로 전송하지 않음.
> Workers 내부에서만 사용하고 외부 API 호출 후 폐기.

### Workers 암호화 코드 (핵심)

```javascript
// wrangler.toml에서 secret 설정 후 사용
// wrangler secret put ENCRYPTION_KEY

async function encrypt(plaintext, env) {
  const key = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(env.ENCRYPTION_KEY),
    { name: 'AES-GCM' },
    false,
    ['encrypt']
  );

  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    new TextEncoder().encode(plaintext)
  );

  return {
    encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
    iv: btoa(String.fromCharCode(...iv))
  };
}

async function decrypt(encryptedB64, ivB64, env) {
  const key = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(env.ENCRYPTION_KEY),
    { name: 'AES-GCM' },
    false,
    ['decrypt']
  );

  const iv = Uint8Array.from(atob(ivB64), c => c.charCodeAt(0));
  const encrypted = Uint8Array.from(atob(encryptedB64), c => c.charCodeAt(0));

  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv },
    key,
    encrypted
  );

  return new TextDecoder().decode(decrypted);
}
```

---

## Workers API 엔드포인트 설계

### 인증 (Google OAuth)

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/auth/google | POST | Google ID Token 검증 → 세션 토큰 발급 (자동 회원가입 포함) |
| /api/auth/me | GET | 현재 로그인 사용자 정보 확인 |
| /api/auth/logout | POST | 로그아웃 (클라이언트 토큰 삭제) |

### 플레이어

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/player | GET | 내 플레이어 정보 조회 |
| /api/player | PUT | 플레이어 정보 저장/업데이트 |

### 몬스터 (오답)

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/monsters | GET | 내 오답 몬스터 목록 |
| /api/monsters | POST | 오답 몬스터 추가 |
| /api/monsters/:id | PUT | 몬스터 상태 변경 |
| /api/monsters/:id | DELETE | 몬스터 삭제 |

### 아이템

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/items | GET | 내 아이템 목록 |
| /api/items | POST | 아이템 추가 |
| /api/items/:id | PUT | 아이템 수정 |

### 플레이 기록

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/runs | GET | 내 플레이 기록 |
| /api/runs | POST | 플레이 기록 저장 |

### 설정

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/settings | GET | 사운드 등 설정 조회 |
| /api/settings | PUT | 설정 저장 |

### API 키 (암호화)

| 엔드포인트 | 메서드 | 설명 |
|-----------|--------|------|
| /api/keys | POST | API 키 암호화 저장 |
| /api/keys/:name | DELETE | API 키 삭제 |
| /api/gemini/generate | POST | Gemini API 호출 (키를 서버에서 복호화 후 사용) |
| /api/image/analyze | POST | 이미지 분석 API 호출 |

> API 키 조회(GET) 엔드포인트는 만들지 않음 — 키가 브라우저로 나가면 안 됨

---

## 프로젝트 파일 구조

```
study-api/
├── wrangler.toml              # Cloudflare 설정
├── src/
│   ├── index.js               # 라우터 (메인 진입점)
│   ├── middleware/
│   │   ├── auth.js            # JWT 세션 토큰 검증 미들웨어
│   │   └── cors.js            # CORS 설정
│   ├── routes/
│   │   ├── auth.js            # Google OAuth 로그인/세션 관리
│   │   ├── player.js          # 플레이어 CRUD
│   │   ├── monsters.js        # 몬스터 CRUD
│   │   ├── items.js           # 아이템 CRUD
│   │   ├── runs.js            # 플레이 기록
│   │   ├── settings.js        # 설정
│   │   └── keys.js            # API 키 암호화 저장/사용
│   └── utils/
│       ├── crypto.js          # AES-GCM 암호화/복호화
│       ├── jwt.js             # 세션 JWT 생성/검증
│       ├── google.js          # Google ID Token 검증
│       └── response.js        # 응답 헬퍼
├── schema.sql                 # D1 테이블 생성 SQL
└── package.json
```

### wrangler.toml 설정

```toml
name = "study-api"
main = "src/index.js"
compatibility_date = "2026-01-31"
account_id = "49225a4bb22b1889f807790e26b324b7"

[[d1_databases]]
binding = "DB"
database_name = "odap-hunter-db"
database_id = "<D1 생성 후 채워넣기>"

[vars]
CORS_ORIGIN = "https://study-bhi.pages.dev"
GOOGLE_CLIENT_ID = "<Google OAuth 클라이언트 ID>"

# secrets (wrangler secret put 명령으로 등록)
# ENCRYPTION_KEY = "32바이트 마스터 암호화 키"
# JWT_SECRET = "JWT 서명용 비밀 키"
# GOOGLE_CLIENT_SECRET = "Google OAuth 시크릿"
```

---

## 보안 설계

| 항목 | 방법 |
|------|------|
| 통신 | HTTPS (Cloudflare 자동) |
| 인증 | Google OAuth 2.0 → 세션 JWT 발급 |
| API 키 저장 | AES-256-GCM 암호화 후 D1 저장 |
| 암호화 마스터키 | Workers Secret (코드에 노출 안 됨) |
| 비밀번호 | 없음 (Google 인증 위임, 비밀번호 관리 불필요) |
| CORS | Pages 도메인만 허용 |
| API 키 노출 방지 | 복호화된 키는 Workers 내부에서만 사용, 브라우저로 전송 안 함 |

---

## 구현 순서

1. **Google Cloud Console**에서 OAuth 클라이언트 ID 생성
2. D1 데이터베이스 생성 (`wrangler d1 create odap-hunter-db`)
3. 스키마 적용 (`wrangler d1 execute --file=schema.sql`)
4. Workers Secret 등록
   - `wrangler secret put ENCRYPTION_KEY`
   - `wrangler secret put JWT_SECRET`
   - `wrangler secret put GOOGLE_CLIENT_SECRET`
5. Workers API 코드 작성 (Google 로그인 + CRUD + 암호화)
6. Workers 배포 (`wrangler deploy`)
7. 프론트엔드(app) 수정
   - Google 로그인 버튼 추가
   - IndexedDB/localStorage → Workers API 호출로 변경
   - 로그인 상태 관리 (세션 토큰)
8. Pages 재배포

---

## 참고 자료
- [Cloudflare D1 공식 문서](https://developers.cloudflare.com/d1/)
- [D1 시작하기](https://developers.cloudflare.com/d1/get-started/)
- [D1 프록시 API 구축 튜토리얼](https://developers.cloudflare.com/d1/tutorials/build-an-api-to-access-d1/)
- [Workers Web Crypto API](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)
- [encrypt-workers-kv (AES-GCM 예제)](https://github.com/bradyjoslin/encrypt-workers-kv)
- [D1 무료 티어 가격](https://developers.cloudflare.com/d1/platform/pricing/)
